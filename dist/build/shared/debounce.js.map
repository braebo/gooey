{"version":3,"file":"debounce.js","sources":["../../../../src/shared/debounce.ts"],"sourcesContent":["/**\n * Creates a debounced version of a function.  The debounced function delays\n * invoking `func` until after `duration` milliseconds have elapsed since the\n * last time the debounced function was invoked.\n */\nexport function debounce(func: Function, duration = 50) {\n\tlet timeout: ReturnType<typeof setTimeout> | null\n\n\treturn function (...args: any[]) {\n\t\tclearTimeout(timeout!)\n\t\ttimeout = setTimeout(() => {\n\t\t\ttimeout = null\n\t\t\tfunc(...args)\n\t\t}, duration)\n\t}\n}\n\ninterface PendingPromise<T> {\n\tresolve: (value: T | PromiseLike<T>) => void\n\treject: (reason?: any) => void\n}\n\n/**\n * Creates a debounced version of a function.  Unlike {@link debounce},\n * `debounceAsync` accepts a sync _or_ async callback, and returns a\n * promise that resolves when the callback fires.\n *\n * @example\n * ```ts\n * async function log() {\n * \tconsole.log('FIRST')\n * \tawait wait(1000)\n * \tconsole.log('LAST')\n * }\n *\n * const logDebounce = debounceAsync(log, 500)\n *\n * for (let i = 0; i < 3; i++) {\n * \tconsole.log(i)\n * \tlogDebounce().then(() => {\n * \t\tconsole.log('DONE')\n * \t})\n * }\n *\n * // Output:\n *\n * // 0\n * // 1\n * // 2\n * // FIRST\n * // DONE\n * // LAST\n * ```\n */\nexport function debounceAsync<T extends (...args: any[]) => any>(func: T, wait: number) {\n\tlet timeout: ReturnType<typeof setTimeout>\n\t// Initialize with no-op functions to avoid checking for undefined later.\n\tlet pendingPromise: PendingPromise<ReturnType<T>> = {\n\t\tresolve: () => {},\n\t\treject: () => {},\n\t}\n\n\treturn function (...args: Parameters<T>): Promise<ReturnType<T>> {\n\t\tclearTimeout(timeout)\n\n\t\ttimeout = setTimeout(() => {\n\t\t\tconst result = func(...args)\n\t\t\tPromise.resolve(result).then(pendingPromise.resolve, pendingPromise.reject)\n\t\t\t// Reset pendingPromise with no-op functions after resolving or rejecting.\n\t\t\tpendingPromise = { resolve: () => {}, reject: () => {} }\n\t\t}, wait)\n\n\t\t// Return a new promise that assigns its resolve and reject to pendingPromise.\n\t\t// This ensures the promise returned by the most recent call controls the outcome.\n\t\treturn new Promise<ReturnType<T>>((resolve, reject) => {\n\t\t\tpendingPromise = { resolve, reject }\n\t\t})\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;;AAIG;SACa,QAAQ,CAAC,IAAc,EAAE,QAAQ,GAAG,EAAE,EAAA;AACrD,IAAA,IAAI,OAA6C,CAAA;IAEjD,OAAO,UAAU,GAAG,IAAW,EAAA;QAC9B,YAAY,CAAC,OAAQ,CAAC,CAAA;AACtB,QAAA,OAAO,GAAG,UAAU,CAAC,MAAK;YACzB,OAAO,GAAG,IAAI,CAAA;AACd,YAAA,IAAI,CAAC,GAAG,IAAI,CAAC,CAAA;SACb,EAAE,QAAQ,CAAC,CAAA;AACb,KAAC,CAAA;AACF;;;;"}