{"version":3,"file":"store.js","sources":["../../../../src/shared/store.ts"],"sourcesContent":["/** Cleanup logic callback. */\ntype Invalidator<T> = (value?: T) => void\n\n/** Pair of subscriber and invalidator. */\ntype SubscribeInvalidateTuple<T> = [Subscriber<T>, Invalidator<T>]\n\n/** Callback to inform of a value updates. */\ntype Subscriber<T> = (value: T) => void\n\n/** Unsubscribes from value updates. */\ntype Unsubscriber = () => void\n\n/** Callback to update a value. */\ntype Updater<T> = (value: T) => T\n\n/**\n * Start and stop notification callbacks.\n * This function is called when the first subscriber subscribes.\n *\n * @param set - Function that sets the value of the store.\n * @param update - Function that sets the value of the store after passing thecurrent value to the\n * update function.\n * @returns Optionally, a cleanup function that is called when the last remaining subscriber\n * unsubscribes.\n */\ntype StartStopNotifier<T> = (\n\tset: (value: T) => void,\n\tupdate: (fn: Updater<T>) => void,\n) => void | (() => void)\n\n/** Readable interface for subscribing. */\nexport interface Readable<T> {\n\t/**\n\t * Subscribe on value changes.\n\t * @param run subscription callback\n\t * @param invalidate cleanup callback\n\t */\n\tsubscribe(this: void, run: Subscriber<T>, invalidate?: Invalidator<T>): Unsubscriber\n}\n\n/** Writable interface for both updating and subscribing. */\nexport interface Writable<T> extends Readable<T> {\n\t/**\n\t * Set value and inform subscribers.\n\t * @param value to set\n\t */\n\tset(this: void, value: T): void\n\n\t/**\n\t * Update value using callback and inform subscribers.\n\t * @param updater callback\n\t */\n\tupdate(this: void, updater: Updater<T>): void\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nfunction safe_not_equal(a: unknown, b: unknown): boolean {\n\treturn a != a\n\t\t? b == b\n\t\t: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function'\n}\n\nconst noop = () => {}\n\nfunction subscribe_to_store<T>(\n\tstore: Readable<T> | null | undefined,\n\trun: (value: T) => void,\n\tinvalidate?: (value: T) => void,\n): () => void {\n\tif (store == null) {\n\t\t// @ts-expect-error\n\t\trun(undefined)\n\n\t\t// @ts-expect-error\n\t\tif (invalidate) invalidate(undefined)\n\n\t\treturn noop\n\t}\n\n\t// Svelte store takes a private second argument\n\t// @ts-expect-error\n\tconst unsub = store.subscribe(run, invalidate)\n\n\t// Also support RxJS\n\t// @ts-expect-error\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub\n}\n\nconst subscriber_queue: Array<SubscribeInvalidateTuple<any> | any> = []\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n */\nexport function readable<T>(value: T, start: StartStopNotifier<T>): Readable<T> {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe,\n\t}\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @param value - initial value\n */\nexport function writable<T>(value: T, start: StartStopNotifier<T> = noop): Writable<T> {\n\tlet stop: Unsubscriber | null = null\n\n\tconst subscribers: Set<SubscribeInvalidateTuple<T>> = new Set()\n\n\tfunction set(new_value: T): void {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]()\n\t\t\t\t\tsubscriber_queue.push(subscriber, value)\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1])\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction update(fn: Updater<T>): void {\n\t\tset(fn(/** @type {T} */ value))\n\t}\n\n\tfunction subscribe(run: Subscriber<T>, invalidate: Invalidator<T> = noop): Unsubscriber {\n\t\t/** @type {SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber: SubscribeInvalidateTuple<T> = [run, invalidate]\n\t\tsubscribers.add(subscriber)\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop\n\t\t}\n\t\trun(/** @type {T} */ value)\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber)\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop()\n\t\t\t\tstop = null\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { set, update, subscribe }\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {Readable<T>} store\n * @returns {T}\n */\nexport function get<T>(store: Readable<T>): T {\n\tlet value: T | undefined\n\tsubscribe_to_store(store, _ => (value = _))()\n\treturn value as T\n}\n"],"names":[],"mappings":"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"}