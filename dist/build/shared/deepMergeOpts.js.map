{"version":3,"file":"deepMergeOpts.js","sources":["../../../../src/shared/deepMergeOpts.ts"],"sourcesContent":["/**\n * Deep merges objects together, with some special rules:\n * - Arrays are concatenated and de-duplicated unless {@link concatArrays|`concatArrays`} is `false`.\n * - Objects are recursively merged.\n * - `false` is only replaced with `true`\n * - An object is never replaced with `true`, `false`, or `undefined`.\n * - The original objects are not mutated.\n * - `undefined` is always overwritten.\n * - `0` is accepted.\n * @todo More options would be nice.\n */\nexport function deepMergeOpts<T, U>(\n\tobjects: [target: T, ...sources: U[]],\n\toptions?: {\n\t\t/**\n\t\t * If `true`, arrays are concatenated and de-duplicated.\n\t\t *\n\t\t * If `false`, arrays are replaced.\n\t\t * @defaultValue `false`\n\t\t */\n\t\tconcatArrays?: boolean\n\t},\n): T & U {\n\tconst [target, ...sources] = objects\n\tconst { concatArrays = true } = options ?? {}\n\n\treturn sources.reduce<T & U>(\n\t\t(acc, curr) => {\n\t\t\tif (!curr) return acc\n\n\t\t\tconst keys = Object.keys(curr)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst k = keys[i] as keyof T & U\n\t\t\t\tconst v = acc[k]\n\t\t\t\tconst newV = curr[k as keyof U] as (T & U)[keyof T & U] | undefined\n\n\t\t\t\tif (Array.isArray(v) && Array.isArray(newV)) {\n\t\t\t\t\tif (concatArrays) {\n\t\t\t\t\t\tacc[k] = [...new Set([...v, ...newV])] as (T & U)[keyof T & U]\n\t\t\t\t\t} else {\n\t\t\t\t\t\tacc[k] = newV\n\t\t\t\t\t}\n\t\t\t\t} else if (v && typeof v === 'object') {\n\t\t\t\t\tif (newV !== true) {\n\t\t\t\t\t\tif (newV && typeof newV === 'object') {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttypeof globalThis.window !== 'undefined' &&\n\t\t\t\t\t\t\t\tnewV instanceof Element\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tacc[k] = newV\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tacc[k] = deepMergeOpts([{ ...v }, newV], options)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (newV || newV === false) {\n\t\t\t\t\t\t\tacc[k] = newV\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (newV !== undefined) {\n\t\t\t\t\tacc[k] = newV\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acc\n\t\t},\n\t\t{ ...target } as T & U,\n\t)\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;AAUG;AACa,SAAA,aAAa,CAC5B,OAAqC,EACrC,OAQC,EAAA;IAED,MAAM,CAAC,MAAM,EAAE,GAAG,OAAO,CAAC,GAAG,OAAO,CAAA;IACpC,MAAM,EAAE,YAAY,GAAG,IAAI,EAAE,GAAG,OAAO,IAAI,EAAE,CAAA;IAE7C,OAAO,OAAO,CAAC,MAAM,CACpB,CAAC,GAAG,EAAE,IAAI,KAAI;AACb,QAAA,IAAI,CAAC,IAAI;AAAE,YAAA,OAAO,GAAG,CAAA;QAErB,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;AAC9B,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACrC,YAAA,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC,CAAgB,CAAA;AAChC,YAAA,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAA;AAChB,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,CAAY,CAAqC,CAAA;AAEnE,YAAA,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBAC5C,IAAI,YAAY,EAAE;AACjB,oBAAA,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC,CAAyB,CAAA;iBAC9D;qBAAM;AACN,oBAAA,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAA;iBACb;aACD;AAAM,iBAAA,IAAI,CAAC,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;AACtC,gBAAA,IAAI,IAAI,KAAK,IAAI,EAAE;AAClB,oBAAA,IAAI,IAAI,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;AACrC,wBAAA,IACC,OAAO,UAAU,CAAC,MAAM,KAAK,WAAW;4BACxC,IAAI,YAAY,OAAO,EACtB;AACD,4BAAA,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAA;yBACb;6BAAM;AACN,4BAAA,GAAG,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,OAAO,CAAC,CAAA;yBACjD;qBACD;AAAM,yBAAA,IAAI,IAAI,IAAI,IAAI,KAAK,KAAK,EAAE;AAClC,wBAAA,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAA;qBACb;iBACD;aACD;AAAM,iBAAA,IAAI,IAAI,KAAK,SAAS,EAAE;AAC9B,gBAAA,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAA;aACb;SACD;AACD,QAAA,OAAO,GAAG,CAAA;AACX,KAAC,EACD,EAAE,GAAG,MAAM,EAAW,CACtB,CAAA;AACF;;;;"}