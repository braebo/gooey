{"version":3,"file":"css-custom-properties.js","sources":["../../../../src/shared/css-custom-properties.ts"],"sourcesContent":["import { entries } from './object'\n\n// import { StandardPropertiesHyphen } from 'csstype'\n\n/**\n * A structured object representing a theme's CSS custom properties.\n */\nexport interface ThemeVars {\n\t[key: string]: StructuredVars\n\tbase: StructuredVars\n\tlight: StructuredVars\n\tdark: StructuredVars\n}\n\n/**\n * A structured object representing CSS custom properties using the following rules:\n * - Each key represents a fragment of the CSS variable name. Fragments are\n *   concatenated with a hyphen `-`,  except for the last fragment, which is\n *   concatenated with an underscore `_` to the preceding fragment(s).\n * - The last key in each branch (each leaf node) must be a valid CSS property,\n *   such as `color`, `min-width`, etc.\n * - The value assigned to the last fragment represents the CSS variable's value.\n *\n * For example, the following object:\n * ```ts\n * { button: { secondary: { color: 'red' } } }\n * ```\n * Maps this CSS variable:\n * ```css\n * { --button-secondary_color: red; }\n * ```\n *\n * @remarks This interface is intended to be used in contexts where CSS variables are\n * dynamically generated or  managed in Typescript, such as the {@link Themer}.\n */\nexport interface StructuredVars {\n\t[key: string]: string | StructuredVars\n}\n\ntype Entries = Array<[string, string]> | IterableIterator<[string, string]>\ntype Prev = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] // Infinite recursion prevention.\n\n/**\n * @internal\n * Unrolls a {@link ThemeVars} object into a flat object of strongly inferred CSS variables\n * where the last key in each branch is concatenated with an underscore `_` to the preceding\n * fragment(s), while all other keys are concatenated with a hyphen `-`.\n */\ntype AccumulateKeys<T, Prefix extends string = '', Depth extends number = 10> = Depth extends 0\n\t? never\n\t: T extends object\n\t\t? {\n\t\t\t\t[K in keyof T]: K extends string\n\t\t\t\t\t? T[K] extends Record<string, any>\n\t\t\t\t\t\t? `${Prefix}${K}-` extends `${infer Rest}-`\n\t\t\t\t\t\t\t? AccumulateKeys<T[K], `${Rest}-`, Prev[Depth]>\n\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t: `${Prefix}${K}` extends `${infer Rest}`\n\t\t\t\t\t\t\t? `${Rest}_${K}`\n\t\t\t\t\t\t\t: never\n\t\t\t\t\t: never\n\t\t\t}[keyof T]\n\t\t: ''\n\ntype FlattenStructuredVars<T, P extends string> = {\n\t[K in AccumulateKeys<T> as `--${P}-${K}`]: string\n}\n\n/**\n * Converts a {@link ThemeVars} object into a flat object of CSS variables.\n */\nexport type DestructuredVars<\n\tObj extends StructuredVars,\n\tPrefix extends string = '',\n> = FlattenStructuredVars<Obj, Prefix>\n\n/**\n * Converts a {@link ThemeVars} object into a flat object of CSS variables.\n * @example\n * ```ts\n * const vars = { root: { header: { width: '1rem' }, // etc... }\n *\n * destructureVars(vars) // { '--root-header_width': '1rem' }\n * ```\n */\nexport function destructureVars<const Obj extends StructuredVars, const Prefix extends string>(\n\tvars: Obj,\n\t_prefix: Prefix,\n) {\n\tconst flatVars: Record<string, string> = {}\n\n\tfunction destructure(o: Record<string, any>, prefix: string = '') {\n\t\tfor (const [k, v] of entries(o)) {\n\t\t\tif (typeof v === 'object') {\n\t\t\t\tdestructure(v, `${prefix ? prefix + '-' : ''}${k}`)\n\t\t\t} else {\n\t\t\t\tflatVars[`${prefix ? prefix + '_' : ''}${k}`] = v\n\t\t\t}\n\t\t}\n\t}\n\n\tdestructure(vars)\n\n\treturn flatVars as Partial<DestructuredVars<Obj, Prefix>>\n}\n\n/**\n * Converts a flat object/map/entries of CSS variables into a {@link ThemeVars} object.\n *\n * @example\n * ```ts\n * // This array of entries:\n * restructure([[ '--root-folder_max-height', '1rem' ]])\n * // is structured into:\n * { root: { folder: { 'max-height': '1rem' } }\n * ```\n */\nexport function restructureVars(\n\tentries: [string, string][] | Map<string, string> | Record<string, string>,\n): StructuredVars {\n\tif (entries instanceof Map) {\n\t\treturn unroll(entries.entries())\n\t} else if (Array.isArray(entries)) {\n\t\treturn unroll(entries)\n\t} else {\n\t\treturn unroll(Object.entries(entries))\n\t}\n}\n\nfunction unroll(entries: Entries): StructuredVars {\n\tconst structuredVars = {} as StructuredVars\n\n\tfor (const [key, value] of entries) {\n\t\tconst parts = key.split(/[_-]/)\n\t\tlet current = structuredVars\n\n\t\tfor (let i = 0; i < parts.length - 1; i++) {\n\t\t\tcurrent[parts[i]] ||= {}\n\n\t\t\tcurrent = current[parts[i]] as ThemeVars\n\t\t}\n\n\t\tcurrent[parts[parts.length - 1]] = value\n\t}\n\n\treturn structuredVars\n}\n\n/**\n * Regex to extract the inner variable name from a CSS variable.\n * @example\n * | `rgba(var(--my-color), 0.5)`.match(CSS_VAR_INNER)[0]\n * > '--my-color'\n */\nexport const CSS_VAR_INNER = /\\bvar\\((--[a-zA-Z0-9_-]+)\\)/g\n\n/**\n * Regex to match a CSS variable.\n * @example\n * | `rgba(var(--my-color), 0.5)`.match(CSS_VAR)[0]\n * > 'var(--my-color)'\n */\nexport const CSS_VAR_OUTER = /(?:var\\()(!?[a-z-]+)/g\n"],"names":[],"mappings":";;AA4EA;;;;;;;;AAQG;AACa,SAAA,eAAe,CAC9B,IAAS,EACT,OAAe,EAAA;IAEf,MAAM,QAAQ,GAA2B,EAAE,CAAA;AAE3C,IAAA,SAAS,WAAW,CAAC,CAAsB,EAAE,SAAiB,EAAE,EAAA;AAC/D,QAAA,KAAK,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE;AAChC,YAAA,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;AAC1B,gBAAA,WAAW,CAAC,CAAC,EAAE,GAAG,MAAM,GAAG,MAAM,GAAG,GAAG,GAAG,EAAE,GAAG,CAAC,CAAA,CAAE,CAAC,CAAA;aACnD;iBAAM;AACN,gBAAA,QAAQ,CAAC,CAAG,EAAA,MAAM,GAAG,MAAM,GAAG,GAAG,GAAG,EAAE,CAAG,EAAA,CAAC,EAAE,CAAC,GAAG,CAAC,CAAA;aACjD;SACD;KACD;IAED,WAAW,CAAC,IAAI,CAAC,CAAA;AAEjB,IAAA,OAAO,QAAkD,CAAA;AAC1D;;;;"}