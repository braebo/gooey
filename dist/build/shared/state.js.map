{"version":3,"file":"state.js","sources":["../../../../src/shared/state.ts"],"sourcesContent":["import type { Writable } from './store'\n\nimport { localStorageStore } from './localStorageStore'\nimport { get, writable } from './store'\n\nexport interface PrimitiveState<T> extends Writable<T> {\n\treadonly isState: true\n\treadonly value: T\n\tonChange: (cb: (v: T) => void) => void\n\tset(this: void, value: T): void\n\trefresh(): void\n}\n\nexport interface ArrayState<T> extends PrimitiveState<T[]> {\n\tpush: (item: T) => void\n}\n\nexport interface MapState<K, V> extends PrimitiveState<Map<K, V>> {\n\t/**\n\t * Set value and inform subscribers.\n\t *\n\t * Note: To update a map, use the `setKey` and `deleteKey` methods.\n\t */\n\tset: (value: Map<K, V>) => void\n\tsetKey: (key: K, value: V) => void\n\tdeleteKey: (key: K) => void\n}\n\nexport interface SetState<T> extends PrimitiveState<Set<T>> {\n\tadd: (item: T) => void\n\tdelete: (item: T) => void\n}\n\nexport type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (\n\tx: infer I,\n) => void\n\t? I\n\t: never\n\nexport type IsUnion<T> = [T] extends [UnionToIntersection<T>] ? false : true\n\nexport type UnionState<T> = { set: (value: T) => void } & Omit<PrimitiveState<T>, 'set'>\n\nexport type State<T> =\n\tIsUnion<T> extends true\n\t\t? UnionState<T>\n\t\t: T extends Array<infer U>\n\t\t\t? ArrayState<U>\n\t\t\t: T extends Map<infer K, infer V>\n\t\t\t\t? MapState<K, V>\n\t\t\t\t: T extends Set<infer U>\n\t\t\t\t\t? SetState<U>\n\t\t\t\t\t: PrimitiveState<T>\n\nexport interface StateOptions<T> extends Partial<Writable<T>> {\n\t/**\n\t * If provided, the store will be persisted to local storage\n\t * under the specified key.\n\t * @default undefined\n\t */\n\tkey?: string\n\t/**\n\t * If provided, localStorage updates will be debounced by\n\t * the specified number of milliseconds. If both `debounce`\n\t * and `throttle` are provided, `debounce` will take precedence.\n\t */\n\tdebounce?: number\n\t/**\n\t * Optional callback function that runs after the store is\n\t * updated and all subscribers have been notified.\n\t */\n\tonChange?: (v: T) => void\n}\n\n/**\n * An advanced store factory with additional features:\n *\n * - Support for Maps, Sets, and Arrays (enabling methods like `.push` and `.add`).\n * - A `.get` method for retrieving the current value of the store.\n * - Optional `onChange` callback for adding side effects without subscribing.\n * - Optional `key` argument for persisting the store to local storage.\n *\n * @param defaultValue - The default value of the store.\n * @param options - {@link StateOptions}\n *\n * @example\n * ```svelte\n * <script lang=\"ts\">\n * \timport { state } from 'fractils'\n *\n * \tconst foo = state([1, 2, 3], { key: 'foo' }) // persisted to local storage\n * \tfoo.push(4)\n * \tfoo.push('5') // Type error\n *\n * \tconst bar = state(new Map<string, number>())\n * \tbar.setKey('count', 21) // `set` is taken, so we use `setKey` and `deleteKey`\n *\n * \tconst baz = state(new Set<number>())\n * \tbaz.add(5)\n * \tbaz.push(6) // Type error\n * </script>\n *\n * <h1>{$foo} {$bar} {$baz}</h1>\n * ```\n */\nexport function state<T>(defaultValue: T, options?: StateOptions<T>): State<T> {\n\tconst store = options?.key\n\t\t? localStorageStore(options.key, defaultValue, {\n\t\t\t\tdebounce: options?.debounce,\n\t\t\t\tonChange: options?.onChange,\n\t\t\t})\n\t\t: writable(defaultValue)\n\n\tfunction enhanceStore<S>(enhancer: (store: State<S>) => void) {\n\t\tif (enhancer) enhancer(store as unknown as State<S>)\n\t}\n\n\tif (Array.isArray(defaultValue)) {\n\t\tenhanceStore<T[]>(store => {\n\t\t\tstore.push = (item: any) => {\n\t\t\t\tstore.update(arr => [...arr, item])\n\t\t\t}\n\t\t})\n\t} else if (defaultValue instanceof Map) {\n\t\tenhanceStore<Map<any, any>>(store => {\n\t\t\tstore.setKey = (key, value) => {\n\t\t\t\tstore.update(map => {\n\t\t\t\t\tmap.set(key, value)\n\t\t\t\t\treturn map\n\t\t\t\t})\n\t\t\t}\n\t\t\tstore.deleteKey = key => {\n\t\t\t\tstore.update(map => {\n\t\t\t\t\tconst newMap = new Map(map)\n\t\t\t\t\tnewMap.delete(key)\n\t\t\t\t\treturn newMap\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\tenhanceStore<Set<any>>(store => {\n\t\tif (defaultValue instanceof Set) {\n\t\t\tstore.add = item => {\n\t\t\t\tstore.update(set => new Set(set).add(item))\n\t\t\t}\n\t\t\tstore.delete = item => {\n\t\t\t\tstore.update(set => {\n\t\t\t\t\tconst newSet = new Set(set)\n\t\t\t\t\tnewSet.delete(item)\n\t\t\t\t\treturn newSet\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t})\n\n\t// if (options?.set) store.set = options.set\n\n\treturn {\n\t\t...store,\n\t\tisState: true as const,\n\t\tget value() {\n\t\t\treturn get(store)\n\t\t},\n\t\tset value(v) {\n\t\t\tif (v === undefined) throw new Error('Cannot set state to undefined')\n\t\t\tstore.set(v)\n\t\t},\n\t\trefresh() {\n\t\t\tstore.set(get(store))\n\t\t},\n\t} as State<T>\n}\n\nexport function isState<T>(v: any): v is State<T> {\n\treturn typeof v === 'object' && v.isState === true\n}\n\nexport function fromState<T>(state: T | State<T>) {\n\treturn (isState(state) ? state.value : state) as T\n}\n\n// //- Test cases\n// {\n// \tconst numArray = state([1, 2, 3])\n// \tnumArray.push(4)\n\n// \tconst myMap = state(new Map<string, number>())\n// \tmyMap.setKey('key1', 100)\n// \tmyMap.set(new Map())\n\n// \tconst mySet = state(new Set<number>())\n// \tmySet.set(new Set())\n// \tmySet.add(5)\n\n// \tconst myString = state('hello')\n// \tmyString.set('world')\n\n// \ttype MyType = 'foo' | 'bar'\n// \tconst myType = state<MyType>('foo')\n// \tmyType.set('bar')\n\n// \ttype Foo = { foo: string }\n// \tconst myObject = state<Foo>({ foo: 'bar' })\n// \tmyObject.set({ foo: 'baz' })\n// }\n"],"names":[],"mappings":"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"}