import type { TooltipOptions } from '../shared/Tooltip';
import { type CreateOptions } from '../shared/create';
export type ButtonClickFunction = () => void;
export type ButtonEventPayload = {
    event: MouseEvent & {
        target: HTMLButtonElement;
    };
    button: ButtonController;
};
export interface ButtonControllerOptions {
    readonly __type?: 'ButtonControllerOptions';
    /**
     * The text or HTML to display on the button.  If a function is passed, it will be called
     * on {@link ButtonController.refresh|`refresh`}.
     * @defaultValue `'click me'`
     */
    text: string | (() => string);
    /**
     * Callback function to run when the button is clicked.  It is passed an object containing the
     * click event, and individual instance of the {@link ButtonController} that was clicked.
     *
     * If not provided, the click event can still be listened to via the `click` event on the
     * {@link ButtonController.on} method.
     * @defaultValue `undefined`
     */
    onClick?: (data: ButtonEventPayload) => void;
    /**
     * Set this option to override the default id applied to the button element.  By default, the
     * id is generated by the {@link Logger} class.
     *
     * In an {@link InputButtonGrid}, the id is also used as the key in the
     * {@link InputButtonGrid.buttons} map for easy access.
     */
    id?: string;
    /**
     * If true, the button will be disabled.  A function can be passed for dynamic disabling, as it
     * will be called whenever the button is refreshed.
     * @defaultValue `false`
     */
    disabled?: boolean | (() => boolean);
    /**
     * Optional css style overrides in {@link JavascriptStyleProperty} (camelCase) format.
     * @example
     * ```ts
     * {
     *   width: '50%',
     *   'backgroundColor': 'red',
     *   border: '1px solid #000',
     * }
     * ```
     * @defaultValue `undefined`
     */
    style?: CreateOptions['style'];
    /**
     * Optional {@link TooltipOptions}.
     * @defaultValue `undefined`
     */
    tooltip?: Partial<TooltipOptions>;
    /**
     * An arbitrary value used externally by {@link InputButtonGrid}.  If a function is passed, it
     * will be called whenever the button is refreshed.
     * @defaultValue `false`
     */
    active?: boolean | (() => boolean);
    /**
     * The button element to wrap.  If not provided, a new button element is created.
     * @defaultValue `undefined`
     */
    element?: HTMLButtonElement;
    /**
     * If provided, the button will be appended to this parent element.
     * @defaultValue `undefined`
     */
    parent?: HTMLElement;
}
export interface ButtonControllerEvents {
    /**
     * Fires when the button is updated externally via the {@link ButtonController.set} method.
     */
    change: ButtonController;
    /**
     * Fires when the button is clicked.
     */
    click: ButtonEventPayload;
    /**
     * Fires when the button is refreshed via the {@link ButtonController.refresh} method.
     */
    refresh: void;
}
export declare const BUTTON_INPUT_DEFAULTS: ButtonControllerOptions;
export declare class ButtonController {
    readonly __type: "ButtonController";
    static is(v: any): v is ButtonController;
    private _text;
    private _active;
    private _disabled;
    element: HTMLButtonElement;
    parent: HTMLElement | undefined;
    private _evm;
    on: <K extends keyof ButtonControllerEvents>(event: K, callback: import("../shared/EventManager").EventCallback<ButtonControllerEvents[K]>) => string;
    private _log;
    constructor(options: Partial<ButtonControllerOptions>);
    get id(): string;
    get text(): string;
    set text(value: string | (() => string));
    get active(): boolean;
    set active(value: boolean | (() => boolean) | undefined);
    /**
     * Set this to `true` to disable the button.  If a function is assigned, it will be called
     * whenever the button is refreshed.
     */
    get disabled(): boolean;
    set disabled(value: boolean | (() => boolean) | undefined);
    /**
     * Update the button with new options.
     */
    set(options: Partial<ButtonControllerOptions>): void;
    click: (event: MouseEvent & {
        target: HTMLButtonElement;
    }) => void;
    enable: () => false | this;
    disable: () => true | this;
    refresh: () => this;
    toJSON(): {
        __type: "ButtonController";
        id: string;
        text: string;
        active: boolean;
        disabled: boolean;
    };
    dispose(): void;
}
